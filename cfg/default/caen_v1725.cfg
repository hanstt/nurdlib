# nurdlib, NUstar ReaDout LIBrary
#
# Copyright (C) 2023-2025
# Hans Toshihide TÃ¶rnqvist
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301  USA

# Some settings depend on the module speed,
# i.e. time-step = (v1725: 4 ns, v1730: 2 ns).

# Firmware version, supported: dpp_psd
version=dpp_psd

# Rely on SIGBUS to terminate buffer reading.
berr = false
# Extended BLT addressing will set address bits 0..23 to 0!
blt_ext = false
blt_mode = noblt

# Waveform length in ns. The time step and # of samples depends on the module
# type:
#  Rounded up to time-step and 8 samples, e.g. v1725: 25 ns -> 7 S -> 8.
#  Max = 0x3fff * time-step.
sample_length = (256 ns {8})

# Rounded up to 0.5V or 2.0V.
range = (2.0 V {16})

# Number of events until channel is transferred for readout, max = 0x3ff.
# High rate -> high to reduce readout overhead.
# Low rate -> low to not wait too long until readout.
aggregate_num = (10 {8})

# Time from the 1st waveform sample to the trigger. Same rounding as for
# sample_length, except 4 samples per step here.
# Max = 0xff * time-step.
# Must be > gate_offset, but nurdlib checks and can complain!
pretrigger_delay = (128 ns {16})

# CFD settings.
#  'delay' can be from 0 ns to 0xff * time-step.
#  'fraction' is in percent, i.e. 25 = 25%, can be [25, 50, 75, 100],
#   rounded down.
#  'width' is the number of samples in both directions from the zero crossing
#  for the intercept interpolation, from 1 to 4.
cfd_delay = (0 ns {16})
cfd_fraction = (25 {16})
cfd_width = (1 {16})

# Input signal suppression, cuts Qlong < zero-suppress.
# Raw values from 0 to 0xffff.
# -1 disables the test.
zero_suppress = (0 {16})

# Short and long charge integration width, and trigger offset.
# Max: short = 0xfff * time-step.
#      long = 0xffff * time-step.
#      offset = 0xff * time-step.
gate_short = (200 ns {16})
gate_long = (2000 ns {16})
gate_offset = (500 ns {16})

# Trigger threshold, leading edge discrimination.
# One step = 0.12 mV for 2 Vpp input range.
#          = 0.03 mV for 0.5 Vpp input range.
# Max values is [0.12, 0.03] * 0x3fff = [1.96, 0.49] V.
# TODO: should be changed to be in mV.  Now: raw values.
threshold = (0 mV {16})

# Fixed baseline.  Only used when baseline_average = 0.
# Max = 0x3fff.
baseline_fixed = (0 {16})

# Trigger gate delay, width, and hold-off width (busy) for coincidence logic.
# Max = delay: 0x3ff * (2 * time-step).
#       width: 0x3ff * (2 * time-step).
#       holdoff: 0xffff * (2 * time-step).
internal_trigger_delay = (0 ns {16})
internal_trigger_width = (100 ns {16})
internal_trigger_holdoff = (150 ns {16})

# PSD threshold.  (Fraction.)
# Max = 1.
threshold_psd = (0.12 {16})

# PUR-GAP threshold.
# Pile-up detection, this sets the peak-valley difference.
# One step = 0.12 mV for 2 Vpp input range.
#          = 0.03 mV for 0.5 Vpp input range.
# Max values is [0.12, 0.03] * 0xfff = [0.12, 0.49] V.
threshold_pur_gap = (0 mV {16})

# input_range = 2 V: 5, 20, 80, 320, 1280, 5120 fC.
# input_range = 0.5 V: 1.25, 5, 20, 80, 320, 1280 fC.
charge = (5 fC {16})

# If true, adds 1024 to the charge.
pedestal = (false {16})

# If true, only sends out triggers on accepted triggers.
trigout_all = (false {16})

# led or cfd.
discrimination = (led {16})

# Should pile-up contribute to output triggers?
pileup_trigout = (false {16})

# Test pulse per channel.
test_pulse = (false {16})

# Test pulse rate: 1, 10, 100, 1000 kHz.
test_pulse_freq = (1 kHz {16})

# Restart baseline forced after long gate.
baseline_restart = (false {16})

# Test pulse polarity.
test_pulse_polarity = (pos {16})

# independent: channels self-trigger.
# coincindence: channels trigger when validation occurs.
# anticoincindence: channels trigger when no validation occurs.
trigger_method = (independent {16})

# # samples for baseline average: 0, 16, 64, 256, 1024.
baseline_average = (16 {16})

# True let's channels self-trigger, false will require mobo to accept.
use_internal_trigger = (true {16})

# Suppress pile-up.
suppress_pileup = (false {16})

# Cut on PSD below or above threshold.
psd_cut_below = (false {16})
psd_cut_above = (false {16})

# Suppress too large integrations.
suppress_over_range = (false {16})

# Suppress triggers on trailing edge of pulse.
trigger_hysteresis = (true {16})

# Polarity detection and CFD zero crossing and whatever...
polarity_detection = (true {16})

# Shaped self-trigger to motherboard.  Channel-coupling options (N even):
#  off:     disabled
#  and:     ch(N) AND ch(N+1)
#  ch_even: ch(N)
#  ch_odd:  ch(N+1)
#  or:      ch(N) OR ch(N+1)
shaped_self_trigger = (off {8})

# Trigger validation for pair of channels.
#  off:     disabled
#  mobo:    signal from motherboard mask
#  and:     ch(N) AND ch(N+1)
#  or:      ch(N) OR ch(N+1)
pair_trigger_validation = (off {8})

# Trigger validation for individual channel (based on pair).
#  pair:    pair validation
#  and:     pair validation and motherboard mask
#  or:      pair validation or motherboard mask
trigger_validation = (pair {16})

# Extra-word format:
#  ext_ts_baseline: 16..31 = ext timestamp ,  0..15 = baseline * 4.
#  ext_ts_flags:    16..31 = ext timestamp ,  0..15 = flags.
#  ext_ts_finetime: 16..31 = ext timestamp , 10..15 = flags, 0..9 = fine time.
#  trig_counts:     16..31 = # lost trigs  ,  0..15 = # trigs.
#  zero_crossing:   16..31 = pos 0-crossing,  0..15 = neg 0-crossing.
#  fixed:            0..31 = 0x12345678.
# Flag bits above:
#  12 = n lost trigs counted.
#  13 = 1024 trigs counted.
#  14 = over-range.
#  15 = trig lost.
extra_word = (ext_ts_finetime {16})

# # samples for smoothing, 0 = disabled.
# Can be 0, 2, 4, 8, 16 samples.  Rounded up.
smoothing = (0 {16})

# Trigger downscale rate for bit 12 in flags of the extra word.
# Can be 128, 1024, 8192.  Rounded up.
trigger_flag_downscale = (1024 {16})

# Veto source.
#  off:       disabled.
#  common:    common veto for all ch.
#  pair:      veto per ch-couple.
#  saturated: veto on saturation.
veto_source = (off {16})

# Piggy-back to mobo signal.
#  0 = over-threshold.
#  2 = self-trigger.
#  3 = pile-up.
#  4 = pile-up or self-trigger.
#  5 = veto.
#  6 = coincidence.
#  7 = trigger validation.
#  8 = veto.
#  9 = neutron pulse for 1 clock.
# 10 = gamma pulse for 1 clock.
# 11 = neutron pulse until end-of-gate.
# 12 = neutron pulse at end-of-gate.
piggy_to_mobo = (2 {16})

# Mark bit 15 in the charge word on saturated pulse.
mark_saturated = (true {16})

# Veto operation mode.
#  false = veto after integration but before saving to memory.
#  true  = veto before integration.  (Early veto = no deadtime.)
veto_direct = (true {16})

# DC offset in raw values.
offset = (0 {16})
# Sleep after DC offset has been set.
init_sleep = 1 s

# Veto can be from 0 ns (duration of signal gate) or 0xffff * 67 * time-step.
veto_width = (0 ns {16})

# # samples before trigger where a dynamic baseline is frozen.
# Max = 0x3ff * time-step.
baseline_freeze = (25 ns {16})

clock_input = internal

# Trigger setting, all OR:ed together.
#  Channels.
trigger_channel = ()
#  Majority trigger, if # overlapping channels reach "level", fire!
majority_width = 0 ns
majority_level = 0
#  Use lemo input for trigger.
trigger_input = lemo

# Lemo level.
lemo = nim
# Output trigger?
trigger_output = true
# LVDS config.
lvds = (0 {4})

# Channels to read out.
channel_enable = (0..15)
